import subprocess as sp
import os, itertools, pysam
from abc import ABC, abstractmethod
from .common import Read, log, SeqRecord, fasta_from_seq, resource_path
from statistics import mean, pvariance
from .read_filter_classes import TtnMappingFilter

class BamFilter(ABC):
    ''' Base class to define interface for classes to recruit read pool from hume genome reference mapping
    '''
    pysam_type_argument_mapping = {'.bam': 'rb', '.sam': 'r', '.cram': 'rc'}
    primary_mapping_only = False
    alternative_chromosome_ids_path = None
    alt_ids = {} # dictionary of alternative chromosome ids. Generated by __init__.
    output_path = None
    reads = set()
    recruited_reads_counter = 0


    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None):
        '''
        Args:
            bam_file_path (str):                path to bam file
            file_type (str):                    Optional: define mapping file type
            primary_mapping_only (bool)         Optional: if True, only extracts reads with primary mapping to extraction regions'''
        log.info(f"Loading reads from {bam_file_path}...")
        if primary_mapping_only:
            self.primary_mapping_only = primary_mapping_only
        if not output_path:
            self.output_path = os.path.splitext(bam_file_path)[0]+'-extracted.fa'
        else:
            self.output_path = output_path

        # check input bam_file_path
        try:
            if not file_type:   
                ext = os.path.splitext(bam_file_path)[1].lower()
                file_type = self.pysam_type_argument_mapping[ext]
            else:
                if not file_type in list(self.pysam_type_argument_mapping.values()):
                    file_type = self.pysam_type_argument_mapping[file_type]
        except KeyError:
            log.error(f'Unsupported alignment file type, please provide mapping file with one of the following extensions: {", ".join(self.pysam_type_argument_mapping.keys())}')
            raise
        
        # load alignment with pysam
        try:
            if file_type == 'rc':
                if not reference_fasta_path:
                    log.error(f"CRAM alignment file provided, please provide path to reference fasta")
                    raise ValueError(f"CRAM alignment file provided, please provide path to reference fasta")
                self.bam = pysam.AlignmentFile(bam_file_path, file_type, reference_filename=reference_fasta_path)
            else:
                self.bam = pysam.AlignmentFile(bam_file_path, file_type)
            self.bam_file_path = bam_file_path
        except ValueError as e:
            log.error(f"Problem loading alignment file: {str(e)}")
            quit()
        
        # make dictionary of alternative chromosome ids
        if self.alternative_chromosome_ids_path:
            with open(self.alternative_chromosome_ids_path, 'r') as f:
                for line in f.readlines():
                    if line[0] == '#':
                        continue
                    line = [y for x in line.split('\t') for y in [x, x.strip().lower(), x.strip().upper()]]
                    key = line[0]
                    line = [y for x in line for y in [x, 'chr_'+x, 'CHR_'+x]]
                    self.alt_ids[key] = set(line)
        for chrom, _, _ in self.regions_to_extract:
            if chrom not in self.alt_ids:
                values = [chrom, chrom.strip().lower(), chrom.strip().upper()]
                values = [y for x in values for y in [x, 'chr_'+x, 'CHR_'+x]]
                self.alt_ids[chrom] = set(values)

    def print_read_count(self):
        ''' prints the number of reads recruited
        '''
        total_read_count = int(int(sp.check_output(['wc', '-l', self.output_path]).split()[0])/2)
        log.info(f"Recruited {total_read_count - self.recruited_reads_counter} reads")
        self.recruited_reads_counter = total_read_count
    
    def extract_reads(self, regions_str='', unmapped=True):
        ''' Extract read sequences from the regions specified and replace '/' in the read names
        Args:
            regions_str     concatenated string of regions in the format chrM:start-end
        '''
        command = f"samtools view -h {self.bam_file_path} {regions_str} | samtools fasta - | sed 's,/,-,' > {self.output_path}"
        log.info(f'Extracting mapped alignments using \n {command}')
        with open(self.output_path, 'w') as f_out:
            p1 = sp.Popen(['samtools', 'view', '-h', f'{self.bam_file_path}', *(regions_str.split())], stdout=sp.PIPE)
            p2 = sp.Popen(['samtools', 'fasta', '-'], stdin=p1.stdout, stdout=sp.PIPE)
            p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
            p3 = sp.Popen(['sed', '-E', r"s;/;-;"], stdin=p2.stdout, stdout=f_out)
            p2.stdout.close()  # Allow p2 to receive a SIGPIPE if p3 exits.
            p3.communicate()

        self.print_read_count()

        if unmapped:
            command = f"samtools fasta -f 0x4 {self.bam_file_path} | sed -E " + r's,/(.),-\1-un,' + f" >> {self.output_path}"
            log.info(f"Extracting unmapped alignments using \n {command}")
            with open(self.output_path, 'a') as f_out:
                p1 = sp.Popen(['samtools', 'fasta', '-f', r'0x4', f'{self.bam_file_path}'], stdout=sp.PIPE)
                p2 = sp.Popen(['sed', '-E', r"s;/(.);-\1-un;"], stdin=p1.stdout, stdout=f_out)
                p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
                p2.communicate()

            self.print_read_count()

    def recruit_reads(self, regions=None, unmapped=True):
        ''' Extracts reads mapping to self.regions_to_extract or regions
        '''
        if os.path.isfile(self.output_path) or os.path.islink(self.output_path):
            log.warn(f'output_path {self.output_path} already exists... Not recruiting reads')
            self.print_read_count()
            return
        if not regions:
            regions = self.regions_to_extract
        
        if not regions:
            self.extract_reads()
            return

        regions_str = ''
        for chrom, start, end in regions:
            try:
                new_chrom = self.find_chrom_id(chrom)
                log.info(f"Recruiting reads from {new_chrom}...")
                regions_str += f'{new_chrom}:{start}-{end} '
            except KeyError as e2:
                log.info(f"Contig {chrom} not present in alignment file")
        self.extract_reads(regions_str, unmapped)

    def find_chrom_id(self, chrom_id):
        '''Takes a chromosome id and finds the matching id that is used in self.bam using self.alt_ids
        Args
            chrom_id (str)              chr id
        Raises
            KeyError if cant find matching id'''
        
        options = [x for x in self.alt_ids[chrom_id] if x in self.bam.references]
        
        if len(options) > 1: #sanity check
            raise ValueError(f"Alignment file has > 1 chromosome reference that matches region id {chrom_id}")
        if len(options) < 1:
            raise KeyError()
        return options[0]

    @property
    @abstractmethod
    def regions_to_extract(self):
        '''Should return a list of regions in the format ("contig_id", start, end)'''
        raise NotImplementedError
    
    def sample_coverage(self, filter=False):
        '''Samples the mean and variance of mapped coverage over a region'''
        chrom, start, end = self.sample_region
        coverage = [0 for x in range(end-start)]
        count_secondary_mappings = 0
        start_count = [0 for x in range(end-start)] # for calculating edge variance
        with open(self.output_path, 'a') as f:
            try:
                new_chrom = self.find_chrom_id(chrom)
                region_mappings = self.bam.fetch(new_chrom, start, end)
                if filter:
                    self.set_sample_filter()
                    pos, neg = self.sample_filter.filter(self.make_sample_region_read_obj(m) for m in region_mappings)
                    print((len(pos), len(neg)))
                    region_mappings = (r.mappings[0] for r in pos)
            except KeyError as e2:
                log.info(f"Contig {chrom} not present in alignment file")
                raise

            for mapping in region_mappings:
                try:
                    if mapping.reference_start < start or mapping.reference_end > end:
                        continue
                except TypeError as e:
                    log.debug(f'Received an excpetion {str(e)} for mapping: {mapping.to_string()}')
                    continue
                if not mapping.is_secondary: #mapping is primary
                    start_count[mapping.reference_start-start] += 1
                    for i in range(mapping.reference_start-start, mapping.reference_end-start):
                        coverage[i] += 1
                else:
                    count_secondary_mappings += 1
        if count_secondary_mappings:
            log.warn(f'Found {count_secondary_mappings} non-primary mappings in coverage sampling region ({self.sample_region})')
        

        #sample edge variance values
        flanking_depths = [[] for x in range(50)]
        for i in range(150, len(start_count)-350): # iterate over every 150 bp region - dont include edges since sloped
            depth_sum = sum(start_count[i:i+101]) # depth at -1 position of 'allele' start
            for flank_pos in range(i+101, i+151):
                depth_sum += start_count[flank_pos]
                flanking_depths[flank_pos-i-101].append(depth_sum)        

        sampled_edge_variance = [pvariance(x) for x in flanking_depths]

        self.sample_coverage_list = coverage
        return mean(coverage), pvariance(coverage), sampled_edge_variance
    

    def set_sample_filter(self):
        self.sample_filter = TtnMappingFilter(*self.sample_region)
    
    def make_sample_region_read_obj(self, mapping):
        '''Makes a Read obj using a single mapping from sampled reagion'''
        result = Read(mapping.query_name, mapping.query_sequence)
        result.mappings = [mapping]
        return result

    @property
    @abstractmethod
    def sample_region(self):
        '''Should return a tuple of the sampling region in the form ("contig_id", start, end)'''
        raise NotImplementedError


class Hg38BamFilter(BamFilter):
    alternative_chromosome_ids_path = resource_path('hg38_chromosome_alt_ids.tsv')
    sample_region = ('chr2', 178561310, 178574416) # titin exon 326

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None, alternative_chromosome_ids_path=None):
        if alternative_chromosome_ids_path:
            self.alternative_chromosome_ids_path = alternative_chromosome_ids_path
        super().__init__(bam_file_path, reference_fasta_path=reference_fasta_path, file_type=file_type, primary_mapping_only=primary_mapping_only, output_path=output_path)


class Hg37BamFilter(BamFilter):
    alternative_chromosome_ids_path = resource_path('hg37_chromosome_alt_ids.tsv')
    sample_region = ('chr2', 179426037, 179439143) # titin exon 326

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None, alternative_chromosome_ids_path=None):
        if alternative_chromosome_ids_path:
            self.alternative_chromosome_ids_path = alternative_chromosome_ids_path
        super().__init__(bam_file_path, reference_fasta_path=reference_fasta_path, file_type=file_type, primary_mapping_only=primary_mapping_only, output_path=output_path)

class IghHg38BamFilter(Hg38BamFilter):

    @property
    def regions_to_extract(self):
        return [('chr14', 105586000, 106881000),               # igh region
                ('chr15', 19954448, 22361989),                 # chr15 orphon
                ('chr16', 31951098, 34014787),                 # chr16 orphon
                ('CHR_HG2365_PATCH', 19954448, 23031747),      # chr15 alt
                ('chr14_KI270726v1_random', 3920, 42978),      # chr14 alt
                ('chr16_KI270728v1_random', 1108845, 1313949), # chr16 alt
                ('chr14_KI270846v1_alt', 105939524, 106876582),  # igh alt
                ('chr21', 10639028, 10650694),                 # chr21 orphon
                ('chr2', 94947001, 94954450),                  # chr2 orphon
                ('chr15_KI270851v1_alt', 22362370, 22364654)     # chr15 alt
                ]

class IghHg37BamFilter(Hg37BamFilter):

    @property
    def regions_to_extract(self):
        return [('chr14', 106031000, 107290000),        # igh region
                ('chr15', 20168895, 23513285),          # chr15 orphon
                ('chr16', 31962439, 33817254),          # chr16 orphon
                ('HG1592_PATCH', 106405000, 107319000), # igh alt
                ('chr21', 10861761, 10873428),          # chr21 orphon
                ('chr2', 95612746, 95620195),           # chr2 orphon
                ]


class IglHg38BamFilter(Hg38BamFilter):

    @property
    def regions_to_extract(self):
        return [('22', 22026077, 22922971),
                ('CHR_HSCHR22_1_CTG3', 22376007, 22628513),
                ('8', 47202438, 47202738),
                ('8', 85036663, 85036820),
                ('12', 114874490, 114874653),
                ('13', 110839095, 110839189)
                ]

class IglHg37BamFilter(Hg37BamFilter):

    @property
    def regions_to_extract(self):
        return [('22', 22380475, 23265143),
                ('8', 48114061, 48114361)]