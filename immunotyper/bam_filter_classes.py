from atexit import register
import subprocess as sp
import os, itertools, pysam
from abc import ABC, abstractmethod
from .common import Read, log, SeqRecord, fasta_from_seq, resource_path, allele_db_mapping_path
from statistics import mean, pvariance
from .read_filter_classes import TtnMappingFilter
import subprocess

class BamFilter(ABC):
    ''' Base class to define interface for classes to recruit read pool from hume genome reference mapping
    '''
    pysam_type_argument_mapping = {'.bam': 'rb', '.sam': 'r', '.cram': 'rc'}
    primary_mapping_only = False
    alt_ids = {} # dictionary of alternative chromosome ids. Generated by __init__.
    output_path = None
    reads = set()
    recruited_reads_counter = 0
    large_sample_chrom = 'chr1'


    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None):
        '''
        Args:
            bam_file_path (str):                path to bam file
            file_type (str):                    Optional: define mapping file type
            primary_mapping_only (bool)         Optional: if True, only extracts reads with primary mapping to extraction regions'''
        log.info(f"Loading reads from {bam_file_path}...")
        if primary_mapping_only:
            self.primary_mapping_only = primary_mapping_only
        if not output_path:
            self.output_path = os.path.splitext(bam_file_path)[0]+f'-{self.gene_type}-extracted.fa'
        elif os.path.isdir(output_path):
            self.output_path = os.path.join(output_path, os.path.splitext(os.path.basename(bam_file_path))[0]+'-extracted.fa')
        else:
            self.output_path = output_path

        # check input bam_file_path
        try:
            if not file_type:   
                ext = os.path.splitext(bam_file_path)[1].lower()
                self.file_type = self.pysam_type_argument_mapping[ext]
            else:
                if not file_type in list(self.pysam_type_argument_mapping.values()):
                    self.file_type = self.pysam_type_argument_mapping[file_type]
                else:
                    self.file_type = file_type
        except KeyError:
            log.error(f'Unsupported alignment file type, please provide mapping file with one of the following extensions: {", ".join(self.pysam_type_argument_mapping.keys())}')
            raise
        
        # load alignment with pysam
        try:
            if self.file_type == 'rc':
                if not reference_fasta_path:
                    log.error(f"CRAM alignment file provided, please provide path to reference fasta")
                    raise ValueError(f"CRAM alignment file provided, please provide path to reference fasta")
                self.reference_fasta_path = reference_fasta_path
                self.bam = pysam.AlignmentFile(bam_file_path, self.file_type, reference_filename=self.reference_fasta_path)
            else:
                self.bam = pysam.AlignmentFile(bam_file_path, self.file_type)
            self.bam_file_path = bam_file_path
        except ValueError as e:
            log.error(f"Problem loading alignment file: {str(e)}")
            quit()
        
        # make dictionary of alternative chromosome ids
        if self.alternative_chromosome_ids_path:
            with open(self.alternative_chromosome_ids_path, 'r') as f:
                for line in f.readlines():
                    if line[0] == '#':
                        continue
                    line = [y for x in line.split('\t') for y in [x, x.strip().lower(), x.strip().upper()]]
                    key = line[0]
                    line = [y for x in line for y in [x, 'chr_'+x, 'CHR_'+x]]
                    self.alt_ids[key] = set(line)
        for chrom, _, _ in self.regions_to_extract:
            if chrom not in self.alt_ids:
                values = [chrom, chrom.strip().lower(), chrom.strip().upper()]
                values = [y for x in values for y in [x, 'chr_'+x, 'CHR_'+x]]
                self.alt_ids[chrom] = set(values)

    def print_read_count(self):
        ''' prints the number of reads recruited
        '''
        total_read_count = int(int(sp.check_output(['wc', '-l', self.output_path]).split()[0])/2)
        log.info(f"Recruited {total_read_count - self.recruited_reads_counter} reads")
        self.recruited_reads_counter = total_read_count
    
    def extract_reads(self, regions_str='', unmapped=True):
        ''' Extract read sequences from the regions specified and replace '/' in the read names
        Args:
            regions_str     concatenated string of regions in the format chrM:start-end
        '''
        log.info(f'Extracting mapped alignments from {regions_str}:\n')
        with open(self.output_path, 'w') as f_out:
            if self.file_type == 'rc':
                _env = {'REF_PATH': self.reference_fasta_path}
                command = ['samtools', 'view', '-T', f'{self.reference_fasta_path}',  '-h', f'{self.bam_file_path}', *(regions_str.split())]
                p1 = sp.Popen(command, env=dict(os.environ, **_env), stdout=sp.PIPE)
            else:
                command = ['samtools', 'view', '-h', f'{self.bam_file_path}', *(regions_str.split())]
                p1 = sp.Popen(command, stdout=sp.PIPE)
            log.info(' '.join(command) + ' |')
            
            command = ['samtools', 'fasta', '-']
            log.info(' '.join(command) + ' |')
            p2 = sp.Popen(command, stdin=p1.stdout, stdout=sp.PIPE)
            p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.

            command = ['sed', '-E', r"s;/;-;"]
            log.info(' '.join(command) + '\n')
            p3 = sp.Popen(command, stdin=p2.stdout, stdout=f_out)
            p2.stdout.close()  # Allow p2 to receive a SIGPIPE if p3 exits.
            
            p3.communicate()

        self.print_read_count()

        if unmapped:
            command = f"samtools fasta -f 0x4 {self.bam_file_path} | sed -E " + r's,/(.),-\1-un,' + f" >> {self.output_path}"
            log.info(f"Extracting unmapped alignments using \n {command}")
            with open(self.output_path, 'a') as f_out:
                if self.file_type == 'rc':
                    _env = {'REF_PATH': self.reference_fasta_path}
                    p1 = sp.Popen(['samtools', 'view', '-h', f'{self.bam_file_path}', *(regions_str.split())], env=dict(os.environ, **_env), stdout=sp.PIPE)
                else:
                    p1 = sp.Popen(['samtools', 'fasta', '-f', r'0x4', f'{self.bam_file_path}'], stdout=sp.PIPE)
                p2 = sp.Popen(['sed', '-E', r"s;/(.);-\1-un;"], stdin=p1.stdout, stdout=f_out)
                p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
                p2.communicate()

            self.print_read_count()

    def recruit_reads(self, regions=None, unmapped=True):
        ''' Extracts reads mapping to self.regions_to_extract or regions
        '''
        try:
            if os.path.isfile(self.output_path) or os.path.islink(self.output_path):
                log.warn(f'output_path {self.output_path} already exists... Not recruiting reads')
                self.print_read_count()
                return
        except sp.CalledProcessError: # file could not be read by `wc -l`
            log.error(f"Could not load reads from {self.output_path}, recruiting reads from BAM...")

        if not regions:
            regions = self.regions_to_extract
        
        if not regions:
            self.extract_reads()
            return

        regions_str = ''
        for chrom, start, end in regions:
            try:
                new_chrom = self.find_chrom_id(chrom)
                log.info(f"Recruiting reads from {new_chrom}...")
                regions_str += f'{new_chrom}:{start}-{end} '
            except KeyError as e2:
                log.info(f"Contig {chrom} not present in alignment file")
        self.extract_reads(regions_str, unmapped)

    def find_chrom_id(self, chrom_id):
        '''Takes a chromosome id and finds the matching id that is used in self.bam using self.alt_ids
        Args
            chrom_id (str)              chr id
        Raises
            KeyError if cant find matching id'''
        options = [x for x in self.alt_ids[chrom_id] if x in self.bam.references]
        
        if len(options) > 1: #sanity check
            raise ValueError(f"Alignment file has > 1 chromosome reference that matches region id {chrom_id}")
        if len(options) < 1:
            raise KeyError()
        return options[0]

    @property
    @abstractmethod
    def regions_to_extract(self):
        '''Should return a list of regions in the format ("contig_id", start, end)'''
        raise NotImplementedError
    
    def sample_coverage(self, filter=False, large_depth_sample=False):
        '''Samples the mean and variance of mapped coverage over a region'''
        chrom, start, end = self.sample_region
        coverage = [0 for x in range(end-start)]
        count_secondary_mappings = 0
        start_count = [0 for x in range(end-start)] # for calculating edge variance
        # with open(self.output_path, 'a') as f:
        try:
            new_chrom = self.find_chrom_id(chrom)
        except KeyError:
            log.info(f"Contig {chrom} not present in alignment file")
            raise

        region_mappings = self.bam.fetch(new_chrom, start, end)

        if filter:
            self.set_sample_filter()
            pos, neg = self.sample_filter.filter(self.make_sample_region_read_obj(m) for m in region_mappings)
            region_mappings = (r.mappings[0] for r in pos)

        for mapping in region_mappings:
            try:
                if mapping.reference_start < start or mapping.reference_end > end:
                    continue
            except TypeError as e:
                log.debug(f'Received an excpetion {str(e)} for mapping: {mapping.to_string()}')
                continue
            if not mapping.is_secondary: #mapping is primary
                start_count[mapping.reference_start-start] += 1
                for i in range(mapping.reference_start-start, mapping.reference_end-start):
                    coverage[i] += 1
            else:
                count_secondary_mappings += 1
        if count_secondary_mappings:
            log.warn(f'Found {count_secondary_mappings} non-primary mappings in coverage sampling region ({self.sample_region})')
        mean_coverage = mean(coverage)

        #sample edge variance values
        flanking_depths = [[] for x in range(50)]
        for i in range(150, len(start_count)-350): # iterate over every 150 bp region - dont include edges since sloped
            depth_sum = sum(start_count[i:i+101]) # depth at -1 position of 'allele' start
            for flank_pos in range(i+101, i+151):
                depth_sum += start_count[flank_pos]
                flanking_depths[flank_pos-i-101].append(depth_sum)        

        sampled_edge_variance = [pvariance(x) for x in flanking_depths]

        if large_depth_sample:
            mean_coverage_large = self.large_depth_sample(self.bam_file_path)
            if not mean_coverage_large:
                log.warn(f"Could not calculate mean depth for {self.bam_file_path} using {self.large_sample_chrom}... Calculating using standard method from {chrom}: {start}-{end}")
                mean_coverage_large = mean_coverage
            else:
                mean_coverage = mean_coverage_large

        self.sample_coverage_list = coverage
        return mean_coverage, pvariance(coverage), sampled_edge_variance
    
    def large_depth_sample(self, bam_file):
        chromosome = self.find_chrom_id(self.large_sample_chrom)

        # Command to execute samtools depth
        command = f"samtools depth -r {chromosome} {bam_file}"

        # Run the command and capture the output
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()

        if process.returncode != 0:
            # Handle errors if samtools command fails
            print("Error in samtools command:", stderr.decode())
            command = f"samtools depth -r {bam_file}"

            # Run the command and capture the output
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                raise ValueError(f"Unable to calculate depth for {bam_file}!")

        # Process the output to calculate mean depth
        total_depth = 0
        total_positions = 0

        for line in stdout.splitlines():
            _, _, depth = line.decode().split()
            total_depth += int(depth)
            total_positions += 1

        # Calculate mean depth
        if total_positions > 0:
            mean_depth = total_depth / total_positions
        else:
            mean_depth = 0

        return mean_depth


    def set_sample_filter(self):
        self.sample_filter = TtnMappingFilter(*self.sample_region)
    
    def make_sample_region_read_obj(self, mapping):
        '''Makes a Read obj using a single mapping from sampled reagion'''
        result = Read(mapping.query_name, mapping.query_sequence)
        result.mappings = [mapping]
        return result

    @property
    @abstractmethod
    def sample_region(self):
        '''Should return a tuple of the sampling region in the form ("contig_id", start, end)'''
        raise NotImplementedError


regions_resource_path = lambda x: resource_path(x, 'immunotyper.data.extract_regions')
class BamFilterImplemented(BamFilter):
    '''Simple wrapper for BamFilter that just requires the gene type and reference genome specified at instantiation. Uses immunotyper package resources (immunotyper.data)'''

    def __init__(self, bam_file_path, gene_type, hg38=True, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None):
        self.alternative_chromosome_ids_path = resource_path('hg38_chromosome_alt_ids.tsv') if hg38 else resource_path('hg37_chromosome_alt_ids.tsv')
        self.hg38 = hg38 
        self.gene_type = gene_type.lower()
        if gene_type.lower() not in allele_db_mapping_path:
            log.warn(f"Gene type {gene_type} does not yet have allele database implemented in immunotyper")
        self.regions_path = regions_resource_path(f"{gene_type.upper()}-{'hg38' if hg38 else 'hg37'}_extract_regions.bed")
        log.debug(f"Using regions file: {self.regions_path}")
        
        super().__init__(bam_file_path, reference_fasta_path, file_type, primary_mapping_only, output_path)
    
    @property
    def regions_to_extract(self):
        '''Depends on self.regions_path'''
        result = []
        with open(self.regions_path, 'r') as f:
            for line in f.readlines():
                chrm, start, end, _ = [x.strip() for x in line.split('\t')]
                result.append((chrm, int(start), int(end)))
        return result

    @property
    def sample_region(self):
        return ('chr2', 178561310, 178574416) if self.hg38 else ('chr2', 179426037, 179439143)

class Hg38BamFilter(BamFilter):
    alternative_chromosome_ids_path = resource_path('hg38_chromosome_alt_ids.tsv')
    sample_region = ('chr2', 178561310, 178574416) # titin exon 326

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None, alternative_chromosome_ids_path=None):
        if alternative_chromosome_ids_path:
            self.alternative_chromosome_ids_path = alternative_chromosome_ids_path
        super().__init__(bam_file_path, reference_fasta_path=reference_fasta_path, file_type=file_type, primary_mapping_only=primary_mapping_only, output_path=output_path)


class Hg37BamFilter(BamFilter):
    alternative_chromosome_ids_path = resource_path('hg37_chromosome_alt_ids.tsv')
    sample_region = ('chr2', 179426037, 179439143) # titin exon 326

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None, alternative_chromosome_ids_path=None):
        if alternative_chromosome_ids_path:
            self.alternative_chromosome_ids_path = alternative_chromosome_ids_path
        super().__init__(bam_file_path, reference_fasta_path=reference_fasta_path, file_type=file_type, primary_mapping_only=primary_mapping_only, output_path=output_path)


class IghHg38BamFilter(Hg38BamFilter):

    @property
    def regions_to_extract(self):
        return [('chr14', 105586000, 106881000),               # igh region
                ('chr15', 19954448, 22361989),                 # chr15 orphon
                ('chr16', 31951098, 34014787),                 # chr16 orphon
                ('CHR_HG2365_PATCH', 19954448, 23031747),      # chr15 alt
                ('chr14_KI270726v1_random', 3920, 42978),      # chr14 alt
                ('chr16_KI270728v1_random', 1108845, 1313949), # chr16 alt
                ('chr14_KI270846v1_alt', 105939524, 106876582),  # igh alt
                ('chr21', 10639028, 10650694),                 # chr21 orphon
                ('chr2', 94947001, 94954450),                  # chr2 orphon
                ('chr15_KI270851v1_alt', 22362370, 22364654)     # chr15 alt
                ]

class IghHg37BamFilter(Hg37BamFilter):

    @property
    def regions_to_extract(self):
        return [('chr14', 106031000, 107290000),        # igh region
                ('chr15', 20168895, 23513285),          # chr15 orphon
                ('chr16', 31962439, 33817254),          # chr16 orphon
                ('HG1592_PATCH', 106405000, 107319000), # igh alt
                ('chr21', 10861761, 10873428),          # chr21 orphon
                ('chr2', 95612746, 95620195),           # chr2 orphon
                ]


#--------------------------------------#
# Below is for backwards compatibility #
#--------------------------------------#


class IglHg38BamFilter(BamFilterImplemented):

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None):
        super().__init__(bam_file_path, 'iglv', True, reference_fasta_path, file_type, primary_mapping_only, output_path)

class IglHg37BamFilter(BamFilterImplemented):

    def __init__(self, bam_file_path, reference_fasta_path=None, file_type=None, primary_mapping_only=False, output_path=None, alternative_chromosome_ids_path=None):
        super().__init__(bam_file_path, 'iglv', False, reference_fasta_path, file_type, primary_mapping_only, output_path, alternative_chromosome_ids_path)
